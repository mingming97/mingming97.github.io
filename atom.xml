<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ljm&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mingming97.github.io/"/>
  <updated>2018-05-17T16:20:15.697Z</updated>
  <id>https://mingming97.github.io/</id>
  
  <author>
    <name>ljm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中文分词</title>
    <link href="https://mingming97.github.io/2018/05/17/chinese-split-word/"/>
    <id>https://mingming97.github.io/2018/05/17/chinese-split-word/</id>
    <published>2018-05-17T09:40:01.000Z</published>
    <updated>2018-05-17T16:20:15.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>&emsp;&emsp;中文分词其实有很多种思路，大多都是建立在HMM模型的基础上。先简要介绍一下HMM模型，HMM模型中有三个要素：A是状态转移概率分布矩阵，简单说就是在任一时刻从一个隐含状态到另一个隐含状态的转移概率构成的矩阵；B是观测概率分布矩阵，其实就是在任一时刻给定隐含状态s生成观测状态o的条件概率$P(o|s)$构成的矩阵；$\pi$是初始概率矩阵，也就是在初始状态下各隐含状态的概率。而一般的HMM模型有三个基本问题：1. 给定模型$\lambda = (A, B, \pi)$和观测序列$O = \{o_1, o_2, \dots, o_t\}$，计算$P(O|\lambda)$，这是评估问题。2. 给定观测序列$O = \{o_1, o_2, \dots, o_t\}$，求解模型$\lambda = (A, B, \pi$，使得$P(O|\lambda)$尽可能大，这是学习问题，若给定隐含状态序列S可以考虑用maximum likelihood来解决，若隐含状态序列则可以用Baum-Welch算法解决，不过这并不是本文重点。3. 给定 给定模型$\lambda = (A, B, \pi)$和观测序列$O = \{o_1, o_2, \dots, o_t\}$，求使得$P(S|O)$最大的隐含状态序列$S = \{s_1, s_2, \dots, s_t\}$，这被称为解码问题或预测问题。对于分词这个任务来说，主要涉及到的是第三个问题。<br>&emsp;&emsp;jieba分词的源码就提供了解决这个问题的一个很好的范例。将隐含状态集合定义为$\{S, B, M, E\}$，S的含义是单字，B的含义是词头，M的含义是词中，E的含义是词尾。在<code>jieba/finaseg/prob_start.py</code>中定义了初始概率$\pi$，在<code>jieba/finaseg/prob_trans.py</code>中定义了状态转移概率$A$，在<code>jieba/finaseg/prob_emit.py</code>中定义了状态观测概率分布$B$，在用基于统计的方法获得以上这些之后就用Viterbi算法求一条使得$P(S|O)$最大的路径就好。（关于Viterbi算法还是在另篇文章中再说。）<br>&emsp;&emsp;考虑一下，此时如果我们不知道B，该如何定义要求解的函数。可以试着模仿Viterbi的想法，用$\delta_i(s)$表示到第i个字时状态为s时的最优值，则$\delta_{i+1}(s’) = max\{\delta_i(s)a_{ss’}P(s|i),  s\in\{S, B, M, E\}\}$，其中$a_{ss’}$是转移概率，$P(s|i)$表示第i个字状态是s的概率（这样定义是有着一定数学原理的，具体推导也借鉴了Viterbi算法原本的定义，核心思想是极大似然）。转移概率可通过统计的方法得到，那么$P(s|i)$呢？影响到这个概率的因素很多，不妨将这个问题转化为一个seq2seq的问题，输入一个序列，输出各个位置的4-tag标注。中文中通过前后文语境都能作为序列标注的依据，从而考虑使用Bi-directional的LSTM来进行这个任务。只要将输出接一层softmax就可以将结果当作概率使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;中文分词其实有很多种思路，大多都是建立在HMM模型的基础上。先简要介绍一下HMM模型，HMM模型中有
    
    </summary>
    
      <category term="NLP" scheme="https://mingming97.github.io/categories/NLP/"/>
    
    
      <category term="NLP" scheme="https://mingming97.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>hexo配置LaTeX公式</title>
    <link href="https://mingming97.github.io/2018/05/15/hexo-latex/"/>
    <id>https://mingming97.github.io/2018/05/15/hexo-latex/</id>
    <published>2018-05-15T13:12:18.000Z</published>
    <updated>2018-05-17T16:15:55.269Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;正常的hexo框架在默认情况下渲染数学公式会有很多问题，可以通过将hexo默认的引擎<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;emsp;&amp;emsp;首先要将之前的```hexo-renderer-marked```卸载，并安装```hexo-renderer-kramed```。</div></pre></td></tr></table></figure></p>
<p>npm uninstall hexo-renderer-marked —save<br>npm install hexo-renderer-kramed —save<br><code>&amp;emsp;&amp;emsp;在这之后建议在hexo的根目录下找到</code>package.json<code>文件，用文本编辑器打开它，删除字符串`hexo-renderer-marked`所在的一行并保存。之所以不直接卸载`hexo-renderer-marked`，是因为其他重要包极有可能在卸载该包的同时被删除。 
&amp;emsp;&amp;emsp;不要忘了行内公式的转义字符，打开</code>./node_modules/kramed/lib/rules<code>，并修改</code>inline.js<code>文件的11和20行，分别修改为</code>escape: /^\([`<em>[]()#$+-.!_&gt;])/,<code>和</code>em: /^\</em>((?:**|[\s\S])+?)*(?!*)/,<code>。
&amp;emsp;&amp;emsp;每次在写文章前，要在YAML font-matter中添加</code>mathjax: true```，这样便能确保启动mathjax引擎进行渲染了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;正常的hexo框架在默认情况下渲染数学公式会有很多问题，可以通过将hexo默认的引擎&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line
    
    </summary>
    
      <category term="hexo" scheme="https://mingming97.github.io/categories/hexo/"/>
    
    
      <category term="LaTeX" scheme="https://mingming97.github.io/tags/LaTeX/"/>
    
      <category term="hexo" scheme="https://mingming97.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>LIS的O(nlogn)实现原理</title>
    <link href="https://mingming97.github.io/2017/08/30/LIS-O-nlogn/"/>
    <id>https://mingming97.github.io/2017/08/30/LIS-O-nlogn/</id>
    <published>2017-08-30T08:07:39.000Z</published>
    <updated>2018-05-17T16:08:41.703Z</updated>
    
    <content type="html"><![CDATA[<p>　　朴素的LIS的<strong>O(n²)</strong>算法是用dp，用d[i]表示a[i]中以i为结尾的LIS的值，那么状态转移方程可表示为<strong>d[i] = max{d[j] | j &lt; i &amp;&amp; a[j] &lt; a[i]} + 1</strong>。显然，对于一个i下的两个不同决策<strong>j，k (j,k &lt; i)，若a[j] &lt; a[k]，d[j] &gt;= d[k]，而a[i] &gt; a[k]时，k显然没有j决策更优</strong>。通过这种思想，我们发现决策有一定的单调性，从而其中可以用二分查找来降低时间复杂度。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>　　我们可以维护一个决策序列B，用<strong>B[i]</strong>表示子序列长度为i时的最小末尾(a中的值)。可以看出如果<strong>i &gt; j</strong>，一定有<strong>B[i] &gt;= B[j]</strong>。原因很简单，看B的定义就可以知道。由上可知B是单调的序列，对于其中的的值可以进行二分查找。</p>
<p>　　所以可以按顺序枚举<strong>a[i]</strong>，如果<strong>a[i]</strong>的值比B中的最大值要大，则将<strong>a[i]</strong>放入<strong>B[i]</strong>的尾部，最大长度加1; 否则对B进行二分查找以找到<strong>a[i]</strong>该放入的位置，<strong>pos = min{j | B[j] &gt; a[i]}</strong>，用a[i]代替B[pos]，使a[i]成为子序列长度为pos时的最小值。大致过程如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (a[i] &gt; B[len<span class="number">-1</span>]) &#123;</div><div class="line">        B[len] = a[i];</div><div class="line">        len++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        pos = binarySearch(len, a[i]);</div><div class="line">        B[pos] = a[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整代码请戳：<a href="https://github.com/mingming97/Algorithms/blob/master/c%2B%2B/LIS-nlogn.cpp" target="_blank" rel="external">ljm’s github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　朴素的LIS的&lt;strong&gt;O(n²)&lt;/strong&gt;算法是用dp，用d[i]表示a[i]中以i为结尾的LIS的值，那么状态转移方程可表示为&lt;strong&gt;d[i] = max{d[j] | j &amp;lt; i &amp;amp;&amp;amp; a[j] &amp;lt; a[i]} +
    
    </summary>
    
      <category term="算法" scheme="https://mingming97.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="https://mingming97.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://mingming97.github.io/2017/08/28/Union-Find/"/>
    <id>https://mingming97.github.io/2017/08/28/Union-Find/</id>
    <published>2017-08-28T09:41:39.000Z</published>
    <updated>2018-05-17T16:08:39.771Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先假设一个情景，一个班级上有很多学习小组，假如Alice，Amy等以A为首字母的属于一个小组，Bob，Ben等以B为首字母的属于一个小组，以此类推。 我们如果想快速查询任意两个人是否属于一个集合（不以首字母为依据），或者将两个学习小组合并为一个，用何种数据结构去组织最快呢。并查集是一种轻量级的数据结构，其本质是一种集合，支持不相交集合的“并”和“查”的操作。由于在特定状况下，可以通过某些特殊处理将这两种操作的时间复杂度降至很低，所以在某些算法，例如tarjan求lca的实现中，也引入了这一数据结构。</p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>　　其实并查集的本质就是一个划分，商集中的每一个元素（集合）内的元素都可以建一棵树，放在一起就变成了森林。对于任意两个个元素，只需要看他们的树根是否相等，就可以判断他们是否属于同一集合；至于两个集合的合并，只需要将一棵树的树根指向另一棵树的树根。那么，可以用<strong>pre[i]</strong>记录i这个结点的父节点，初始化时只需令<strong>pre[i] = i</strong>，意味着每一个结点都属于一个单独的集合，也就是每一个节点都是树根。如果想查找树根怎么办呢？ 按照定义<strong>pre[i]</strong>是i的父亲，<strong>pre[pre[i]]</strong>就是i结点父亲的父亲，按照这个方式不断向上找直至<strong>pre[i]</strong>等于i，就找到了树根，可以使用递归来实现。如果想合并两个集合怎么办呢，只需要找到两个元素所在树的树根，将一个树根指向另一个，就完成了。</p>
<h2 id="时间复杂度优化"><a href="#时间复杂度优化" class="headerlink" title="时间复杂度优化"></a>时间复杂度优化</h2><h3 id="启发式合并"><a href="#启发式合并" class="headerlink" title="启发式合并"></a>启发式合并</h3><p>　　为了解决合并时树退化成链的情况，在合并时我们可以根据两棵树的深度合并，将最大深度小的向最大深度大的合并。如果两棵树的深度一样，则随便选一个作为根，并将根的最大深度+1。这样做的话在n次操作后，任何一棵树（一个集合）的深度最大不会超过<strong>[logn]+1</strong>，从而使查找的时间复杂度降为$O(logn)$。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> rx = find(x), ry = find(y);</div><div class="line">    <span class="keyword">if</span> (rx != ry) &#123;</div><div class="line">        <span class="keyword">if</span> (rank[rx] == rank[ry]) &#123;</div><div class="line">            pre[ry] = rx;</div><div class="line">            rank[rx]++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rank[rx] &lt; rank[ry]) &#123;</div><div class="line">            pre[rx] = ry;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            pre[ry] = rx;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>　　一般情况下我们只需要知道知道一个元素所在的树的根就可以，所以可以在查找元素的过程中，把路径上的所有子节点直接指向根节点，这样就可以将查找的复杂度降至O(1)。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> x == pre[x] ? x : pre[x] = find(pre[x]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="应用时的问题"><a href="#应用时的问题" class="headerlink" title="应用时的问题"></a>应用时的问题</h2><p>　　在具体问题中，两棵树是否可以按秩合并，以及是否可以路径压缩是需要按照题的要求来定的，本文只是提出了大体框架及基本实现（可移步<a href="https://github.com/mingming97/Algorithms/blob/master/c%2B%2B/union-find.cpp" target="_blank" rel="external">我的github</a>查看）。具体节点信息的维护或是节点合并顺序等还需要自己判断。
　  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　首先假设一个情景，一个班级上有很多学习小组，假如Alice，Amy等以A为首字母的属于一个小组，Bob，Ben等以B为首字母的属于一个小组，以此类推。 我们如果想快速查询任意两个人是否属于一个集合（不以首字母为依据），或者将两个学习小组合并为一个，用何种数据结构去组织最
    
    </summary>
    
      <category term="算法" scheme="https://mingming97.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="并查集" scheme="https://mingming97.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="数据结构" scheme="https://mingming97.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
